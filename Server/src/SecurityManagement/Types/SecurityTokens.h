/* 
 * Copyright (C) 2014 https://github.com/sndnv
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef SECURITYTOKENS_H
#define	SECURITYTOKENS_H

#include <algorithm>
#include <boost/thread/future.hpp>
#include <boost/shared_ptr.hpp>

#include "Types.h"
#include "../../Common/Types.h"
#include "../../InstructionManagement/Types/Types.h"

using InstructionManagement_Types::InstructionSetType;

namespace SecurityManagement_Types
{
    typedef unsigned long long TokenID;
    const TokenID INVALID_TOKEN_ID = 0;
    
    /**
     * Class representing tokens generated by the <code>SecurityManager</code> for
     * authorizing instructions.
     */
    class AuthorizationToken
    {
        public:
            /**
             * Constructs a new authorization token with the supplied parameters.
             * 
             * @param tokenID the unique ID of the token
             * @param signatureData the unique signature of the token
             * @param set the instruction set which the token is generated for
             * 
             * @throw invalid_argument if any of the arguments are invalid
             */
            AuthorizationToken(TokenID tokenID, RandomData signatureData, InstructionSetType set)
            : id(tokenID), signature(signatureData), authorizedSet(set)
            {
                if(id <= INVALID_TOKEN_ID)
                    throw std::invalid_argument("AuthorizationToken::() > Invalid token ID supplied.");
                
                if(signature.size() <= 0)
                    throw std::invalid_argument("AuthorizationToken::() > Invalid signature supplied.");
                
                if(set == InstructionSetType::INVALID)
                    throw std::invalid_argument("AuthorizationToken::() > Invalid instruction set supplied.");
            }
            
            AuthorizationToken(const AuthorizationToken & other) = delete;
            AuthorizationToken(AuthorizationToken && other) = delete;
            AuthorizationToken & operator=(const AuthorizationToken & other) = delete;
            AuthorizationToken & operator=(AuthorizationToken && other) = delete;
            
            ~AuthorizationToken() {}
            
            /** Retrieves the ID of the token.\n\n@return the token ID */
            TokenID getID() const { return id; }
            /** Retrieves the signature of the token.\n\n@returnt the token signature */
            RandomData getSignature() const { return signature; }
            /** Retrieves the authorized instruction set type.\n\n@return the set type */
            InstructionSetType getAuthorizedSet() const { return authorizedSet; }
            
            bool operator==(const AuthorizationToken & rhs) const
            {
                return (id == rhs.id && signature == rhs.signature && authorizedSet == rhs.authorizedSet);
            }
            
            bool operator!=(const AuthorizationToken & rhs) const
            {
                return !(*this == rhs);
            }
            
        private:
            TokenID id;
            RandomData signature;
            InstructionSetType authorizedSet;
    };
    
    typedef boost::shared_ptr<AuthorizationToken> AuthorizationTokenPtr;
    typedef boost::promise<AuthorizationTokenPtr> AuthorizationTokenPromise;
    typedef boost::shared_ptr<AuthorizationTokenPromise> AuthorizationTokenPromisePtr;
    
    /**
     * Class representing tokens generated by the <code>SecurityManager</code> for
     * authenticating users and devices.
     */
    class AuthenticationToken
    {
        public:
            /**
             * Constructs a new authentication token with the supplied parameters.
             * 
             * @param tokenID the unique ID of the token
             * @param signatureData the unique signature of the token
             * @param expiration the expiration time of the token
             * @param userID the ID of the user associated with the token
             * @param deviceID the ID of the device associated with the request (optional)
             * 
             * @throw invalid_argument if any of the arguments are invalid
             */
            AuthenticationToken(TokenID tokenID, RandomData signatureData,
                                Common_Types::Timestamp expiration, Common_Types::UserID userID,
                                Common_Types::DeviceID deviceID = Common_Types::INVALID_DEVICE_ID)
            : id(tokenID), signature(signatureData), expirationTime(expiration),
              user(userID), device(deviceID)
            {
                if(id <= INVALID_TOKEN_ID)
                    throw std::invalid_argument("AuthenticationToken::() > Invalid token ID supplied.");
                
                if(signature.size() <= 0)
                    throw std::invalid_argument("AuthenticationToken::() > Invalid signature supplied.");
                
                if(isExpired())
                    throw std::invalid_argument("AuthenticationToken::() > The token has already expired.");
                
                if(user == Common_Types::INVALID_USER_ID)
                    throw std::invalid_argument("AuthenticationToken::() > Invalid user ID supplied");
            }
            
            AuthenticationToken(const AuthenticationToken & other) = delete;
            AuthenticationToken(AuthenticationToken && other) = delete;
            AuthenticationToken & operator=(const AuthenticationToken & other) = delete;
            AuthenticationToken & operator=(AuthenticationToken && other) = delete;
            
            ~AuthenticationToken() {}
            
            /** Retrieves the ID of the token.\n\n@return the token ID */
            TokenID getID() const { return id; }
            /** Retrieves the signature of the token.\n\n@returnt the token signature */
            RandomData getSignature() const { return signature; }
            /** Retrieves the expiration time of the token.\n\n@returnt the token expiration time */
            Common_Types::Timestamp getExpirationTime() const { return expirationTime; }
            /** Checks whether or not the token has expired.\n\n@return <code>true</code>, if the token has expired */
            bool isExpired() const { return (expirationTime <= boost::posix_time::second_clock::universal_time()); }
            /** Retrieves the ID of the user associated with the token.\n\n@return the user ID */
            Common_Types::UserID getUserID() const { return user; }
            /** Retrieves the ID of the device associated with the token.\n\n@return the device ID, if any */
            Common_Types::DeviceID getDeviceID() const { return device; }
            
            bool operator==(const AuthenticationToken & rhs) const
            {
                return (id == rhs.id
                        && signature == rhs.signature
                        && expirationTime == rhs.expirationTime
                        && user == rhs.user
                        && device == rhs.device);
            }
            
            bool operator!=(const AuthenticationToken & rhs) const
            {
                return !(*this == rhs);
            }
            
        private:
            TokenID id;
            RandomData signature;
            Common_Types::Timestamp expirationTime;
            Common_Types::UserID user;
            Common_Types::DeviceID device;
    };
    
    typedef boost::shared_ptr<AuthenticationToken> AuthenticationTokenPtr;
    typedef boost::promise<AuthenticationTokenPtr> AuthenticationTokenPromise;
    typedef boost::shared_ptr<AuthenticationTokenPromise> AuthenticationTokenPromisePtr;
}

#endif	/* SECURITYTOKENS_H */

